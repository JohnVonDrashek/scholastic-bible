---
import BaseLayout from '../layouts/BaseLayout.astro';

const base = import.meta.env.BASE_URL;
---

<BaseLayout title="Search">
  <h1>Search the Bible</h1>

  <div class="search-container">
    <input
      type="search"
      id="search-input"
      placeholder="Search for words, phrases, or topics..."
      autocomplete="off"
      autofocus
    />
    <div id="search-status" class="search-status"></div>
  </div>

  <div id="search-results" class="search-results"></div>
</BaseLayout>

<style>
  .search-container {
    margin-bottom: 2rem;
  }

  #search-input {
    width: 100%;
    padding: 1rem 1.25rem;
    font-size: 1.1rem;
    font-family: var(--font-serif);
    border: 2px solid var(--color-border);
    border-radius: 8px;
    background: var(--color-bg);
    color: var(--color-text);
    transition: border-color 0.2s, box-shadow 0.2s;
  }

  #search-input:focus {
    outline: none;
    border-color: var(--color-accent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-accent) 20%, transparent);
  }

  #search-input::placeholder {
    color: var(--color-muted);
  }

  .search-status {
    margin-top: 0.75rem;
    font-size: 0.9rem;
    color: var(--color-muted);
    min-height: 1.5em;
  }

  .search-status.loading::after {
    content: '...';
    animation: dots 1s steps(3, end) infinite;
  }

  @keyframes dots {
    0%, 20% { content: '.'; }
    40% { content: '..'; }
    60%, 100% { content: '...'; }
  }

  .search-results {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  :global(.search-result) {
    padding: 1rem 1.25rem;
    border: 1px solid var(--color-border);
    border-radius: 8px;
    background: var(--color-bg);
    text-decoration: none;
    color: inherit;
    display: block;
    transition: border-color 0.2s, box-shadow 0.2s;
  }

  :global(.search-result:hover) {
    border-color: var(--color-accent);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  }

  :global(.search-result .ref) {
    font-family: var(--font-heading);
    font-size: 1rem;
    font-weight: 500;
    color: var(--color-accent);
    margin-bottom: 0.5rem;
  }

  :global(.search-result .snippet) {
    font-size: 0.95rem;
    line-height: 1.6;
    color: var(--color-text);
  }

  :global(.search-result .snippet mark) {
    background: var(--color-highlight);
    color: inherit;
    padding: 0 0.15em;
    border-radius: 2px;
  }

  :global(.search-result .match-type) {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    margin-top: 0.5rem;
    font-size: 0.8rem;
    color: var(--color-muted);
  }

  :global(.no-results) {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--color-muted);
  }

  :global(.no-results h2) {
    margin-bottom: 0.5rem;
  }
</style>

<script define:vars={{ base }}>
  // Store base URL for use in client script
  window.__BASE_URL__ = base;
</script>

<script>
  import Fuse from 'fuse.js';

  interface Verse {
    id: string;
    ref: string;
    book: string;
    bookName: string;
    chapter: number;
    verse: number;
    text: string;
    footnotes: string[] | null;
    challoner: string[] | null;
    summary: string | null;
  }

  interface SearchIndex {
    verses: Verse[];
  }

  let fuse: Fuse<Verse> | null = null;
  let searchIndex: SearchIndex | null = null;
  let debounceTimer: number | null = null;

  const base = (window as any).__BASE_URL__ || '/';

  async function loadSearchIndex(): Promise<void> {
    const statusEl = document.getElementById('search-status');
    if (statusEl) {
      statusEl.textContent = 'Loading search index';
      statusEl.classList.add('loading');
    }

    try {
      const response = await fetch(`${base}search-index.json`);
      if (!response.ok) throw new Error('Failed to load search index');

      searchIndex = await response.json();

      // Initialize Fuse.js
      fuse = new Fuse(searchIndex!.verses, {
        keys: [
          { name: 'text', weight: 1.0 },
          { name: 'footnotes', weight: 0.8 },
          { name: 'challoner', weight: 0.7 },
          { name: 'summary', weight: 0.6 }
        ],
        includeMatches: true,
        threshold: 0.3,
        minMatchCharLength: 3,
        ignoreLocation: true
      });

      if (statusEl) {
        statusEl.textContent = '';
        statusEl.classList.remove('loading');
      }

      // Check for query param
      const params = new URLSearchParams(window.location.search);
      const query = params.get('q');
      if (query) {
        const input = document.getElementById('search-input') as HTMLInputElement;
        if (input) {
          input.value = query;
          performSearch(query);
        }
      }
    } catch (error) {
      console.error('Failed to load search index:', error);
      if (statusEl) {
        statusEl.textContent = 'Failed to load search index. Please refresh the page.';
        statusEl.classList.remove('loading');
      }
    }
  }

  function getMatchType(matches: readonly Fuse.FuseResultMatch[] | undefined): { icon: string; label: string } {
    if (!matches || matches.length === 0) {
      return { icon: '', label: '' };
    }

    const key = matches[0].key;
    switch (key) {
      case 'text':
        return { icon: '', label: 'matched in verse text' };
      case 'footnotes':
        return { icon: '', label: 'matched in footnote' };
      case 'challoner':
        return { icon: '', label: 'matched in commentary' };
      case 'summary':
        return { icon: '', label: 'matched in chapter summary' };
      default:
        return { icon: '', label: '' };
    }
  }

  function highlightMatch(text: string, indices: readonly [number, number][] | undefined): string {
    if (!indices || indices.length === 0) return escapeHtml(text);

    // Sort indices by start position
    const sorted = [...indices].sort((a, b) => a[0] - b[0]);

    let result = '';
    let lastIndex = 0;

    for (const [start, end] of sorted) {
      // Add text before match
      result += escapeHtml(text.slice(lastIndex, start));
      // Add highlighted match
      result += `<mark>${escapeHtml(text.slice(start, end + 1))}</mark>`;
      lastIndex = end + 1;
    }

    // Add remaining text
    result += escapeHtml(text.slice(lastIndex));

    return result;
  }

  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function getSnippet(item: Verse, matches: readonly Fuse.FuseResultMatch[] | undefined): string {
    if (!matches || matches.length === 0) {
      // No matches found, show truncated verse text
      return item.text.length > 150 ? item.text.slice(0, 150) + '...' : item.text;
    }

    const match = matches[0];
    let text = '';

    // Get the matched text content
    if (match.key === 'text') {
      text = item.text;
    } else if (match.key === 'footnotes' && item.footnotes) {
      text = item.footnotes.join(' ');
    } else if (match.key === 'challoner' && item.challoner) {
      text = item.challoner.join(' ');
    } else if (match.key === 'summary' && item.summary) {
      text = item.summary;
    } else {
      text = item.text;
    }

    // Truncate if needed while preserving match context
    if (text.length > 200 && match.indices && match.indices.length > 0) {
      const firstMatch = match.indices[0][0];
      const start = Math.max(0, firstMatch - 50);
      const end = Math.min(text.length, firstMatch + 150);

      let snippet = text.slice(start, end);
      if (start > 0) snippet = '...' + snippet;
      if (end < text.length) snippet = snippet + '...';

      // Adjust indices for the truncated text
      const adjustedIndices = match.indices
        .filter(([s, e]) => s >= start && e <= end)
        .map(([s, e]) => [s - start + (start > 0 ? 3 : 0), e - start + (start > 0 ? 3 : 0)] as [number, number]);

      return highlightMatch(snippet, adjustedIndices);
    }

    return highlightMatch(text, match.indices);
  }

  function renderResults(results: Fuse.FuseResult<Verse>[]): void {
    const container = document.getElementById('search-results');
    if (!container) return;

    if (results.length === 0) {
      container.innerHTML = `
        <div class="no-results">
          <h2>No results found</h2>
          <p>Try different keywords or check your spelling.</p>
        </div>
      `;
      return;
    }

    // Limit to 50 results
    const limited = results.slice(0, 50);

    container.innerHTML = limited.map(result => {
      const item = result.item;
      const matchType = getMatchType(result.matches);
      const snippet = getSnippet(item, result.matches);
      const url = `${base}${item.book}/${item.chapter}/#v${item.verse}`;

      return `
        <a href="${url}" class="search-result">
          <div class="ref">${escapeHtml(item.ref)}</div>
          <div class="snippet">${snippet}</div>
          ${matchType.label ? `<div class="match-type">${matchType.label}</div>` : ''}
        </a>
      `;
    }).join('');
  }

  function performSearch(query: string): void {
    const statusEl = document.getElementById('search-status');
    const container = document.getElementById('search-results');

    if (!query.trim()) {
      if (statusEl) statusEl.textContent = '';
      if (container) container.innerHTML = '';
      // Clear URL param
      const url = new URL(window.location.href);
      url.searchParams.delete('q');
      window.history.replaceState({}, '', url.toString());
      return;
    }

    if (!fuse) {
      if (statusEl) statusEl.textContent = 'Search index not loaded yet...';
      return;
    }

    const results = fuse.search(query);

    if (statusEl) {
      statusEl.textContent = results.length === 0
        ? `No results for "${query}"`
        : `Found ${results.length} result${results.length === 1 ? '' : 's'} for "${query}"`;
    }

    // Update URL param
    const url = new URL(window.location.href);
    url.searchParams.set('q', query);
    window.history.replaceState({}, '', url.toString());

    renderResults(results);
  }

  function setupSearch(): void {
    const input = document.getElementById('search-input') as HTMLInputElement;
    if (!input) return;

    input.addEventListener('input', () => {
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }

      debounceTimer = window.setTimeout(() => {
        performSearch(input.value);
      }, 300);
    });

    // Handle form submission (Enter key)
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }
        performSearch(input.value);
      }
    });
  }

  // Initialize on page load
  document.addEventListener('astro:page-load', () => {
    loadSearchIndex();
    setupSearch();
  });
</script>
